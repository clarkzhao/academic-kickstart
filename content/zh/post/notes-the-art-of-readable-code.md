---
title: "读《编写可读代码的艺术》"
date: 2018-11-11T00:13:00+08:00

# View.
#   1 = List
#   2 = Compact
#   3 = Card
view: 2

# Optional header image (relative to `static/img/` folder).
# header:
#   caption: ""
#   image: ""
categories: [CS]
toc: true
---





工作后，陆陆续续也做了几个项目，本书中所提到的几个注意点确实深有体会。这本能够围绕提高代码可读性这个原则，介绍了从变量名、注释、控制流、表达式、类/方法等多个方面优化代码的方法。这个读书笔记总结了作者的主要想法，起到了快速查阅的作用。

<!--more-->

既然本书是关于提高代码可读性的，那么提高代码可读性到底重不重要呢？

我认为答案并非绝对的。对于书中提到的那些一劳永逸即可提升的点，最好仔细理解并贯彻，比如变量的命名方式，函数的结构等等，这些其实是节省自己以及别人未来的时间。

对于另一些每次运用都需要花费额外时间的点，比如额外的注释等等，建议哪怕项目再赶，宏观级注释也是需要的，因为它不需要花费过多额外的时间，却至少这可以帮助到未来的自己理解代码。

剩下的就见仁见智了，也许未来的我们都会有新的理解。

附：豆瓣地址: [中文版](https://book.douban.com/subject/10797189/)，[英文版](https://book.douban.com/subject/5442971/)


 {{% toc %}}


# 前言、代码应当易于理解

- 可读性基本定理

    >   **代码的写法应当使别人理解它所需的时间最小化。**





# 一、表面层次的改进



## 把信息装到变量的名字中

- 选择专业的词

    - 比如将下表左列指代不清的词换成右列中更为细分的词



| 单词  | 其他选择                         |
| ----- | -------------------------------- |
| get   | fetch, download                  |
| stop  | kill, pause, resume              |
| send  | deliver, dispatch, distribute    |
| find  | search, locate, extract          |
| start | launch, create, begin, open      |
| make  | create, build, add, compose, new |

- 避免泛泛的词

    -   避免 `tmp` 这种泛泛的词
    -   好的名字应当描述变量的目的或者它所承载的值
        -   如用`sum_squares` 代替 `tmp`
        -   `tmp`如果是文件，则用 `tmp_file` 更好
        -   循环迭代器 `i, j, k` 如果循环太多，容易搞混，最好用它所循环的变量名作为前缀如`club_i, member_i, user_i` 或者 `ci, mi, ui` 代替

- 用具体的名字代替抽象的名字

    -   哪些名字非常抽象呢，想象自己是一个新加入项目的成员，能否快速通过名字知道这个变量所表达的信息

- 为名字附带更多的信息

    - 后缀加单位

        -   如 `start -> start_ms`

    - 附带其他信息

        - 未处理的变量前加 `raw_`

        - 如纯文本的密码变量 `pwd -> plaintext_pwd`

        - 匈牙利表示法是严谨的此类方法的命名系统

            它把变量的类型信息放在了变量名最前面如

            `pLast`表示数据结构中最后一个元素的指针

- 名字要不要太长

    -   怎么选择变量名的长短，如

        -   `d, days, days_since_last_update`
    -   小的作用域里写短名字
    -   代码补全可以让输入长名字不再痛苦
    -   只是用通用的缩略词，避免首字母缩略
        -   比如 `str -> string` 是很通用的写法
        -   `LF -> Load Factor` 就容易让人费解
    -   拿掉不会损失信息的词

        -   `ConverToString - > ToString`
    -   利用名字的格式来传递含义
        -   类变量后面加后缀`offset_`

        -   全部大写表示常量 `MAX_FILE_CNT`



## 不会误解的名字

多问自己几遍：“这个名字会被解读成其他的含义吗？”

-   如 `filter` 究竟是过滤剩下的还是直接减去的意思？
-   `max_length` 如果代表最大字符数，用`max_chars` 更好，因为`length` 指代不清晰

-   使用 `min` 和 `max` 代表极限值，这样就可以明确是 `>` 和 `<` 而不是`>=`和`<=` 了
-   使用 `first` 和 `last` 来代表包含的范围
-   使用 `begin` 和 `end` 来代表排除的范围

    -   `end`代表刚好超过最后一个值
-   布尔值命名前加上`is, has, can, should`

    -   避免使用反义词
-   与使用者的期望匹配
    -   `get()` 和 `size()` 给人很容易得到的感觉，如果是要计算均值用`compute_mean（）` 比 `get_mean()`好



## 审美

-   审美三原则

    -   使用一致的布局
    -   相似的代码看上去相似
    -   把相关的代码行分组，形成代码块
        -   把相似的想法归类
        -   提供“脚印”
        -   便于段落间的导航

-   变量申明调用时，使用有意义的顺序

    -   如果在一段代码提到A、 B 和 C， 那么不要在另 一段中说 B、 C 和 A。 选择一个有意义的顺序， 并始终用这样的顺序。

-   把申明按逻辑组织起来

    -   用空行和注释把不同阶段的代码分开来

-   个人风格的一致性

    -   缩进
    -   换行处



## 改写什么样的注释

>   注释的目的是为了帮助读者了解的和作者一样多

- 当我们写代码时，脑海里有很多有价值的信息，但是读者除了注释能看到的只有代码，所以注释包含的信息非常重要

- 哪些不需要注释

    - 没有提供新的信息

    - 不能帮助读者更好的理代码

    - **不要为那些从代码本身就能快速推断的事实写注释**

        ```python
        # Bad comment 
        # ===========
        # y equals x plus 1
        y = x + 1
        
        # Good comment
        # ============
        # remove everything after the second *
        name = '*'.join(line.split('*')[:2])
        ```

    - 避免为了注释而注释

        -   比如重写一遍函数的输入变量

    - 不要给不好的名字加注释，把名字改好

        -   好代码 > 坏代码 + 好注释

- 用代码记录你的思想

    - 好的注释就是写代码中产生的重要想法

    - 电影制作者在其中给出自己的见解来通过讲故事来帮助你理解这部电影如何制作的。代码的注释也应该起到类似的效果

    - 为代码的瑕疵写注释 


| 标记  | 通常的意义                               |
| ----- | ---------------------------------------- |
| TODO  | 我还没有处理的事                         |
| FIXME | 已知的无法运行的代码                     |
| HACK  | 对一个问题不得不采用的比较粗糙的解决方案 |
| XXX   | 危险！这里有很重要的事                   |



- 代码如何改动的想法应该被记录下来。此类注释帮助读者认识代码当前的质量和状态，甚至可以指导未来代码的改进方向
- 给常量加注释
    - 记录下决定这个常量值时的想法
- 站在读者的角度，去想象他们需要知道什么
    -   想象你的代码对于外人看起来是什么样子的，这个人并不熟悉你的项目
    -   将细节写在注释中，解释为什么代码这么写而不那么写的内在理由
    -   为普通读者意料之外的行为加上注释
    -   公布有可能存在的陷阱，未雨绸缪
        -   与其让用户慢慢发现问题，不如提前告知风险
    -   全局关的注释
        -   解释系统的各个组成部分
        -   文件级别的注释
    -   总结性的注释
        -   解释后面的代码块做什么
        -   不能简单的说注释只能用于解释“为什么”的问题而不能用于说明“是什么”的问题， 具体问题具体分析。
    -   只要能帮到用户理解代码的，就是好注释。
- 克服不敢写注释的方法

    -   不管心里想什么，先写下来
    -   读一下这段注释，改进



## 写出言简意赅的注释

>   注释应该有很高的信息/空间率

- 让注释保持紧凑

- 避免使用不明确的代词

    -   `it, this`到底指什么

- 润色粗糙的注释

- **精确**的描述函数的行为

    -   如统计行数的行数，定义清楚行数到底怎么统计的，是数 `\n` 呢还是数 `\r` 呢？

- 用输入输出的例子来说明特别情况

    -   有些时候一个好的例子顶的上很多句话

- 要包含新的新信息，而非解释代码字面上的意思。从高层次解释这段程序做了什么

    -   这样做的好处在于可以让读者明白作者真正的意图，可能与实际代码有冲突，起到了冗余检查的角色

- 让函数的参数有名字

    ```python
    Connect(timeout=10, use_encryption=False)
    ```

    ```C++
    Connect(/* timeout_ms = */10, /* use_encryption */ = False)
    ```

- 采用信息量很高的词，代替经常出现的编程场景

    -   Caching layer
    -   heurisitc
    -   bruteforce 
    -   naive solution





# 二、简化循环和逻辑



## 让控制流变得易读

>   避免复杂的逻辑，巨大的表达式，一大堆变量，因为这增加了我们的思维包袱，这与容易理解矛盾，容易引起 bug 。

- 条件语句中参数的顺序


    | 比较的左侧             | 比较的右侧             |
    | ---------------------- | ---------------------- |
    | 被查询的表达式，偏变量 | 被比较的表达式，偏常量 |
    
    这条原则和英文（中文）的语法一致

- `if/else` 的顺序
    -   先处理正逻辑
    -   先处理简单情况
    -   先处理有趣、可疑的情况
    -   前三者有冲突时，视情况决定
- 条件表达式
    -   相对于追求最小化的代码行数，一个更好的度量方法是最小化人们理解的时间
    -   默认使用 `if/else` 只在最简单的情况下，使用简化的语法糖
- 避免`do/while` 语句，尽量让条件判断出现在最前面

- 从函数中提前返回没有问题，只要保证调用函数结尾的清理代码就行
- 慎用`goto`
- 最小化嵌套
    -   当对代码进行改动时，从全新的角度审视它，把它作为一个整体来看。
    -   通过提早返回来减少嵌套
        -   每一个`if` 都以`return` 或 `continue` 结束

- 谨慎的对待语言的高级特性，确保我们清楚代码的执行流程



## 拆分超长的表达式

>   代码中的表达式越长，越难以理解，尝试把它拆成若干的小块

- 总结变量

    -   讲一个表达式用总结变量存下来，后面再复用这个总结变量

- 使用德摩根定理 [De Morgan's laws](https://en.wikipedia.org/wiki/De_Morgan%27s_laws)

    -   非 (P 且 q) = (非 p) 或 (非 q)
    -   非 (p 或 q) = (非 p) 且 (非 q)

- 避免滥用短路逻辑

    尽管有些语言存在特性`if(a||b) ` 在 `a` 为真是不会执行 `b`

    还是老老实实用 `if/else`比较好

- 小心智能的小代码段，它们除了炫技毫无意义，只会去让人困惑，不利于后期维护

- 拆分复杂逻辑的一个方向是尝试它的逆逻辑

- 多个一样的表达式可以提取出来成为变量
    -   避免录入错误
    -   减少行宽，更易阅读
    -   方便改动，不必多次修改同类代码
- 用宏简化重复的同类表达



## 变量与可读性

>   跟踪变量的三个问题
>
>   -   变量越多，就越难全部跟踪它们的动向
>   -   变量作用域越大，就需要跟踪它们的动向越久
>   -   变量改动的越平凡，就越难确定它们的当前值




- 减少变量
    -   减少没有价值的临时变量
        -   没有拆分复杂的表达式
        -   没有做出更多的澄清
        -   只用了一次，没有压缩任何冗余
    -   减少用来保存中间结果的变量
    -   减少控制流变量
        -   这类变量唯一的目的就是控制程序的执行
        -   这类变量可以用更好地结构化编程来消除
        -   有多层循环时，可以把循环中的代码或者整个循环挪到一个新函数中
        -   微软的 Eric Brechner 说过：“一个好的面试题起码要涉及三个变量。” 因为同时处理三个变量可以强迫人努力思考，但是我们的代码并不是用来面试我们的同事的。

- 缩小变量的作用域

    >    **让你的变量对尽量少的代码行可见**

    -   如果有一个类变量只有两个方法调用了，那么就可以把这个类变量降格成局部变量，因为它不需要被其他方法看见

    -   把定义下移
        -   原来C语言要求有所变量在代码最前面声明
        -   现在可以在它使用前才声明

- 只写一次的变量更好





# 三、重新组织代码

三种组织函数级别代码的改动

1.  抽取出那些与程序主要目的不相关的子问题，变成新的函数
2.  重新组织代码，使它们一次只做一件事
3.  先用自然语言描述代码，再用这个描述帮助找到更整洁的解决方案



## 抽取不相干的子问题

-   纯工具代码可以自己写或者调库
    -   文件 I/O
    -   操作字符串
    -   哈希表
-   创建大量通用的代码
    -   从项目其他部分中解耦出来
    -   容易开发&测试
    -   项目的其他部分会更小且更容易思考

-   简化已有的接口
    -   永远不要安于使用不理想的接口
    -   创建自己的包装函数来隐藏粗陋的接口
-   必要时，按需要重塑接口
-   避免过犹不及，不要引入过多的小函数



## 一次只做一件事

>   应该把代码组织的一次只做一件事

![do_one_thing_at_a_time](http://p9283q7hh.bkt.clouddn.com/do_one_thing_at_a_time.png)



这个原则不仅适用于一个小函数，而且适用于将大的业务函数整理有序

流程：

1.  列出代码所需做的所有任务
2.  尽量把这件任务拆分到不同的函数中，或者至少是代码的不同段落中

-   从对象中抽取需要的值
    -   比如对象是一个字典，我们需要这个字典的若干的键对应的值，可以将这写值保存在变量中，抽取出来。这样就不必记住复杂的健值了

Tips

	`a||b||c` 可以返回第一个真值



## 把想法变成代码

>   如果你不能把一件事解释给你的祖母听的话说明你还没有真正理解它。 
>	​							                             阿尔伯特 爱因斯坦

编写清晰代码的方法

1.  像对着一个同事一样用自然语言描述代码要做什么
2.  注意描述中的关键词
3.  写出与所描述匹配的代码

-   清楚的描述逻辑
-   了解已有的函数库
-   运用递归



## 少写代码

>   最好的代码就是没有代码

**写代码的最高境界就是不写代码。**

这句话虽有调侃之意，却隐含着哲学思辨，时刻问自己，我们真的需要写这些代码吗？

不要低估写代码的时间，因为实现或许不费功夫，但是将来的代码库的维护，都会增加时间



-   质疑和拆分你的需求
    -   有时候，解决一半问题可能只需要花费四分之一的时间
    -   消除不必要的功能
-   保持小代码库
    -   创建越来越多的“工具”代码来减少重复代码（第十章）
    -   减少无用代码或者没有用的功能
    -   让项目分开保持子项目状态
    -   总的来说，小心代码的重量。保持轻灵
-   类似植物剪枝，代码也应该勤快的修剪
    -   创造性的工作都不会保留之前所有的工作，比如电影、音乐、作者

-   熟悉周边的库
    -   其实现有的库可以解决大部分问题，不要重复造轮子，我们的时间更重要。
    -   使用 UNIX 命令行代替代码

-   避免过度设计

-   用最简单的方法完成工作



# 四、精选话题



## 测试与可读性

>   测试应当具有可读性，以方便其他人可以舒服的更改或增加测试。

- 普遍的测试原则

    -   应当对使用者隐去不重要的细节，以便其他更重要的细节突出

- 创建最小的测试声明

    -   大多数测试的基本内容都能精练成 “对于这样的输入或情形， 期望有 这样的行为或输出”。

- 让错误消息具备可读性

    -   更好版本的 `assert()`
- 更好的测试输入
    -   **应当选择一组最简单的输入，前提是它能完整的使用被测代码**
    -   简化输入值
        -   **又简单又能完成工作的测试值更好**

- 一个功能，多个测试

    -   一个测试测试一个方向的bug，避免在一个测试函数内尝试所有情况

- 为测试函数命名

    -   `Test_<FunctionName>`

    -   `Test_<FunctionName>_<situation>`
    -   测试函数的名字就是注释

- 测试驱动的开发 Test-Drive Development

    -   解耦的最好的类往往是最容易测试的
    -   避免程序内部类和类之间方法的调用
    -   在写代码时想着测试就能有帮助，会促使我们停下来思考是否存在更好的设计
    -   坏代码

    ![bad_deisgn_for_test](http://p9283q7hh.bkt.clouddn.com/bad_deisgn_for_test.png)

    - 好代码


| 特征                         | 对测试的好处                           | 对设计的好处                                                 |
| ---------------------------- | -------------------------------------- | ------------------------------------------------------------ |
| 类只有很少的内部状态         | 很容易写出测试                         | 更易理解                                                     |
| 类/函数只做一件事            | 需要较少的测试用例                     | 较小/简单的组件更加模块化，系统能有较低耦合                  |
| 每个类对别的类依赖小，低耦合 | 每个类可以独立测试                     | 系统可以并行开发，可以很容易的修改或者删除类，不会影响其他组件 |
| 函数接口简单，定义明确       | 有明确的行为可以测试，测试接口工作量小 | 接口更容易让程序员学习，复用概率高                           |

- 避免走的太远（Don't be too over）

    -   牺牲真实代码的可读性
    -   沉迷100%的测试覆盖率
    -   考虑投入产出比，有些bug不值得测试
    -   别让测试成为产品开发的阻碍
